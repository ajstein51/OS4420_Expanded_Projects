%{
/* Note: apparently only 4-8 lines in here
 * Simple example lex input file
 *
 * Shawn Ostermann -- Sept 9, 2021
 *
 * Headstart version
 */

#include <string.h>
#include <ctype.h>
#include "parser.h"

/* some internal files generated by bison */
void yyerror(const char *s,...);
void yywarn(const char *s,...);


/* Everything up to the funny characters on the next line */
/* goes directly into the lex.yy.c file */
%}
/* shorthand definitions for later */
DIGIT		[0123456789]
LETTER		[a-zA-Z]
OTHERCHARS	[_\./]
WHITESPACE	[ \t]

/* i added */
WORD        [^|\n<>"&<<>> ]

/* The rest of this after the '%%' is lex rules */
%%

{WHITESPACE}+	{ }  /* Just ignore white space */

"\n" 	        { return(EOLN); } 
"|"             { return(PIPE); }
"<"             { return(INPUT); }
">"             { return(OUTPUT); } // stdout redirect create
">>"            { return(OUTPUT_APPEND); } // stdout redirect append
"2>"            { return(ERROUT); } // stderr create
"2>>"           { return(ERROUTPUT_APPEND); } // stderr append

%{
/* you need rules for the other reserved characters */


/* you need a rule that returns WORD */


/* you need a rule that returns "strings" as WORDS */
%}

{WORD}+ {
    /* printf("scanner saw a word: %s \n", yytext); */
    yylval.string = strdup(yytext); /* gotten from arith2 */
    return(WORD);
}

{OTHERCHARS} {
    yylval.string = strdup(yytext);
    return(OTHERCHARS);
}

\"[^"\n]*\" {
    int j = 1, counter = 1;
    for(int i = 0; i < strlen(yytext); i++){
        if(counter++ != (strlen(yytext) - 1)){
            /* debug printf("%c ", yytext[j]); */
            yytext[i] = yytext[j]; /* quote -> T */
            j++;
        }
        else
            yytext[i] = '\0', yytext[strlen(yytext)] = '\0';
    }
    yylval.string = strdup(yytext);

    /* printf("This is the quote: %s\n", yylval.string); */
    return(WORD);
}

.		{
    /* if we haven't matched anything yet, then it's illegal */
    //fprintf(stderr, "scanner: Bad character '%c'\n", *yytext);
    yyerror(yytext);
}

%%
/* lotta notes from class
[a-z]+ { include, _ .  /
    printf("scanner saw word: %s \n", yytext)
    yylval.string = strdup(yytext);
    return(WORD)
}

^ means not everything after 
word cant have > < | \n

[^|\n]+ { **FOR WORD**
    printf(saw a word)
    yylval.string
}

doline
i 
pipe = 1
pcmd_head;

printf(": %s", )

in parser.y:
look at the parenthesis calc for the "finish the rest of this..."
- finish the word, then go to bash.c and have it print shit out



*****  Friday Class: *****
void catch_ctrk_c(int sig_num){
    char *msg  = "user pressed ctrl-c goodbyte";
    write(1,msg, strlen(msg));
    exit(-1);
}
int main(){
    signmal(SIGINT, catch_ctrl_c);
    while(1){ printf("waiting"); sleep(5);};
}

\"[a-z]*\"    for a string

line : command
    | command PIPE line
    ;

notes on above: 
    PIPE = a token
    a line is either a command or a command a pipe symbol then a line

what is a command?
    a word
    a argument
    or redirection

cmd : WORD args (optional redirction)
    {
        $$ is the cmd
        $2 is a position
        $2 = something
        // some stuff
    }
    ;

args : arg args
    | { $$ = NULL }
    note: on empty rule we do $$ = NULL
    ;
Note above:
    all the recursion must be left recursive? (must be arg followed by args)
arg : WORD

struct args{
    // notes on this
    as we walk through arg we build a link list (example arith1)
    when we get to args we got the link list and we just walk through it

    OR
    we could use a static array: char *args[MAX], max = 10
    int argument
    when we see the arg we just put it at the end of the array
    then when we get to args we just walk through the array and build
}



*/