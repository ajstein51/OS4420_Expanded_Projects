%{
/* Note: apparently only 4-8 lines in here
 * Simple example lex input file
 *
 * Shawn Ostermann -- Sept 9, 2021
 *
 * Headstart version
 */

#include <string.h>
#include <ctype.h>
#include "parser.h"
#include "bash.h"

/* some internal files generated by bison */
void yyerror(const char *s,...);
void yywarn(const char *s,...);
extern struct var vars;


/* Everything up to the funny characters on the next line */
/* goes directly into the lex.yy.c file */
%}
/* shorthand definitions for later */
DIGIT		[0123456789]
LETTER		[a-zA-Z]
OTHERCHARS	[_\./]
WHITESPACE	[ \t]

/* i added */
WORD        [^|\n<>"&<<>>= ]

VARNAME     [a-zA-Z0-9_]
ARGS        [a-zA-Z0-9""]

/* The rest of this after the '%%' is lex rules */
%%

{WHITESPACE}+	{ }  /* Just ignore white space */

"\n" 	        { return(EOLN); } 
"|"             { return(PIPE); }
"<"             { return(INPUT); }
">"             { return(OUTPUT); } // stdout redirect create
">>"            { return(OUTPUT_APPEND); } // stdout redirect append
"2>"            { return(ERROUT); } // stderr create
"2>>"           { return(ERROUTPUT_APPEND); } // stderr append

%{
/* you need rules for the other reserved characters */


/* you need a rule that returns WORD */


/* you need a rule that returns "strings" as WORDS */
%}

{VARNAME}+\=\"[^"\n]*{ARGS}+\" {
    yylval.string = strdup(yytext);
    vars.quoteinit = yylval.string;
    vars.expansion = 0;
    return(WORD);
}

{VARNAME}+\={ARGS}+ {
    // printf("\nWe got a variable %s \n", yytext);

    // get the string
    yylval.string = strdup(yytext); 

    vars.init = yylval.string;
    vars.expansion = 0;
    return(WORD);
}

{WORD}+ {
    // printf("scanner saw a word: %s \n", yytext); 
    yylval.string = strdup(yytext); /* gotten from arith2 */
    vars.expansion = 0;
    yylval.string = var_replace(yylval.string);
    return(WORD);
}

{OTHERCHARS} {
    yylval.string = strdup(yytext);
    return(OTHERCHARS);
}

\'[^'\n]*\' {
    int j = 1, counter = 1;
    for(int i = 0; i < strlen(yytext); i++){
        if(counter++ != (strlen(yytext) - 1)){
            /* debug printf("%c ", yytext[j]); */
            yytext[i] = yytext[j]; /* quote -> T */
            j++;
        }
        else
            yytext[i] = '\0', yytext[strlen(yytext)] = '\0';
    }
    yylval.string = strdup(yytext);

    /* printf("This is the quote: %s\n", yylval.string); */
    vars.expansion = -1;
    return(WORD);
}

\"[^"\n]*\" {
    int j = 1, counter = 1;
    for(int i = 0; i < strlen(yytext); i++){
        if(counter++ != (strlen(yytext) - 1)){
            /* debug printf("%c ", yytext[j]); */
            yytext[i] = yytext[j]; /* quote -> T */
            j++;
        }
        else
            yytext[i] = '\0', yytext[strlen(yytext)] = '\0';
    }
    yylval.string = strdup(yytext);
    vars.expansion = 0;

    yylval.string = var_replace(yylval.string);
    // printf("This is the quote: %s\n", yylval.string); 
    return(WORD);
}

.		{
    /* if we haven't matched anything yet, then it's illegal */
    //fprintf(stderr, "scanner: Bad character '%c'\n", *yytext);
    yyerror(yytext);
}

%%